package dev.tigr.ares.fabric.impl.modules.exploit;

import dev.tigr.ares.core.feature.module.Category;
import dev.tigr.ares.core.feature.module.Module;
import dev.tigr.ares.core.setting.Setting;
import dev.tigr.ares.core.setting.settings.numerical.FloatSetting;
import dev.tigr.ares.core.setting.settings.numerical.IntegerSetting;
import dev.tigr.ares.core.util.Timer;
import dev.tigr.ares.core.util.render.Color;
import dev.tigr.ares.fabric.utils.render.RenderUtils;
import dev.tigr.ares.fabric.utils.WorldUtils;
import net.minecraft.block.AirBlock;
import net.minecraft.block.FluidBlock;
import net.minecraft.block.PlantBlock;
import net.minecraft.item.BlockItem;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.hit.HitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.Direction;

@Module.Info(name = "AirInteract", description = "Allows you to place blocks in the air", category = Category.EXPLOIT)
public class AirInteract extends Module {
    public static AirInteract INSTANCE;

    private final Setting<Integer> delay = register(new IntegerSetting("Place Delay", 4, 0, 6));
    private final Setting<Float> colorRed = register(new FloatSetting("Red", 0.69f, 0f, 1f));
    private final Setting<Float> colorGreen = register(new FloatSetting("Green", 0.69f, 0f, 1f));
    private final Setting<Float> colorBlue = register(new FloatSetting("Blue", 0.69f, 0f, 1f));
    private final Setting<Float> fillAlpha = register(new FloatSetting("Fill Alpha", 0.24f, 0f, 1f));
    private final Setting<Float> boxAlpha = register(new FloatSetting("Line Alpha", 1f, 0f, 1f));

    private Timer placeDelay = new Timer();

    private BlockPos target;
    private Direction side;

    public AirInteract() {
        INSTANCE = this;
    }

    @Override
    public void onTick() {
        if(MC.crosshairTarget instanceof BlockHitResult || MC.player.getMainHandStack().getItem() instanceof BlockItem) {

            BlockHitResult crosshair = (BlockHitResult) MC.crosshairTarget;
            target = crosshair.getBlockPos();
            side = crosshair.getSide();

            if(crosshair.getType() == HitResult.Type.BLOCK) {
                switch (side) {
                    case EAST:
                        target = target.east();
                        break;
                    case SOUTH:
                        target = target.south();
                        break;
                    case WEST:
                        target = target.west();
                        break;
                    case NORTH:
                        target = target.north();
                        break;
                    case DOWN:
                        target = target.down();
                        break;
                    default:
                        target = target.up();
                }
            }
            if(placeDelay.passedTicks(delay.getValue())) {
                if(MC.options.keyUse.isPressed() && MC.player.getMainHandStack().getItem() instanceof BlockItem) {
                    placeDelay.reset();
                    WorldUtils.placeBlockMainHand(false, -1, -1, false, false, target, true, true, getCorrectSide(target, side));
                }
            }
        }
    }

    // draw target
    @Override
    public void onRender3d() {
        if(MC.player.getMainHandStack().getItem() instanceof BlockItem) {
            Box render = new Box(target);
            if (render != null) {
                Color fillColor = new Color(colorRed.getValue(), colorGreen.getValue(), colorBlue.getValue(), fillAlpha.getValue());
                Color outlineColor = new Color(colorRed.getValue(), colorGreen.getValue(), colorBlue.getValue(), boxAlpha.getValue());
                RenderUtils.prepare3d();
                RenderUtils.cube(render, fillColor, outlineColor);
                RenderUtils.end3d();
            }
        }
    }

    // I'm not sure why this doesn't work 100% of the time, but it works enough that it's worth having - Makrennel
    private Direction getCorrectSide(BlockPos blockPos, Direction side) {
        switch (side) {
            case EAST:
                if(isBlock(blockPos.east())) {
                    return side;
                } else return null;
            case SOUTH:
                if(isBlock(blockPos.south())) {
                    return side;
                } else return null;
            case WEST:
                if(isBlock(blockPos.west())) {
                    return side;
                } else return null;
            case NORTH:
                if(isBlock(blockPos.north())) {
                    return side;
                } else return null;
            case DOWN:
                if(isBlock(blockPos.down())) {
                    return side;
                } else return null;
            default:
                if(isBlock(blockPos.up())) {
                    return side;
                } else return null;
        }
    }

    private boolean isBlock(BlockPos blockPos) {
        return !(MC.world.getBlockState(blockPos).getBlock() instanceof AirBlock
                || MC.world.getBlockState(blockPos).getBlock() instanceof FluidBlock
                || MC.world.getBlockState(blockPos).getBlock() instanceof PlantBlock);
    }
}
