package dev.tigr.ares.fabric.impl.modules.exploit;

import dev.tigr.ares.core.feature.module.Category;
import dev.tigr.ares.core.feature.module.Module;
import dev.tigr.ares.core.setting.Setting;
import dev.tigr.ares.core.setting.settings.BooleanSetting;
import dev.tigr.ares.core.setting.settings.EnumSetting;
import dev.tigr.ares.core.setting.settings.numerical.DoubleSetting;
import dev.tigr.ares.core.setting.settings.numerical.IntegerSetting;
import dev.tigr.ares.core.util.global.ReflectionHelper;
import dev.tigr.ares.fabric.event.client.PacketEvent;
import dev.tigr.ares.fabric.event.player.DamageBlockEvent;
import dev.tigr.ares.fabric.utils.InventoryUtils;
import dev.tigr.ares.fabric.utils.RenderUtils;
import dev.tigr.ares.fabric.utils.Timer;
import dev.tigr.simpleevents.listener.EventHandler;
import dev.tigr.simpleevents.listener.EventListener;
import net.minecraft.block.BlockState;
import net.minecraft.client.network.ClientPlayerInteractionManager;
import net.minecraft.item.Items;
import net.minecraft.item.PickaxeItem;
import net.minecraft.network.Packet;
import net.minecraft.network.packet.c2s.play.HandSwingC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
import net.minecraft.util.Hand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.MathHelper;

/**
 * @author Makrennel
 * Credit to Kami147 for the module off which this was based.
 */
@Module.Info(name = "InstantMine", description = "Instantly mines blocks after packet mining the first one.", category = Category.EXPLOIT)
public class InstantMine extends Module {
    public static InstantMine INSTANCE;

    private final Setting<Boolean> repeatMine = register(new BooleanSetting("Repeat", true));
    private final Setting<Double> repeatRange = register(new DoubleSetting("Repeat Range", 5, 0, 10)).setVisibility(repeatMine::getValue);
    private final Setting<Integer> delay = register(new IntegerSetting("Delay", 120, 0, 1200));
    private final Setting<Boolean> pickOnly = register(new BooleanSetting("Only Pickaxe", true));
    private final Setting<Boolean> autoSwitch = register(new BooleanSetting("Auto Switch", false)).setVisibility(pickOnly::getValue);
    private final Setting<Swing> swingType = register(new EnumSetting<>("Swing", Swing.Real));

    private final Setting<Boolean> showColorSettings = register(new BooleanSetting("Color Settings", false));
    private final Setting<Integer> colorRed = register(new IntegerSetting("Red", 255, 0, 255)).setVisibility(showColorSettings::getValue);
    private final Setting<Integer> colorGreen = register(new IntegerSetting("Green", 255, 0, 255)).setVisibility(showColorSettings::getValue);
    private final Setting<Integer> colorBlue = register(new IntegerSetting("Blue", 120, 0, 255)).setVisibility(showColorSettings::getValue);
    private final Setting<Integer> fillAlpha = register(new IntegerSetting("Fill Alpha", 24, 0, 100)).setVisibility(showColorSettings::getValue);
    private final Setting<Integer> boxAlpha = register(new IntegerSetting("Box Alpha", 71, 0, 100)).setVisibility(showColorSettings::getValue);

    enum Swing { None, Real, Packet }

    private Timer repeatTimer = new Timer();
    private BlockPos last;
    private BlockPos render;
    private boolean cancel = false;
    private Direction direction;

    public InstantMine() {
        INSTANCE = this;
    }

    private boolean shouldRepeat = true;
    public void setShouldRepeat(Boolean shouldRepeat) {
        INSTANCE.shouldRepeat = shouldRepeat;
    }

    @EventHandler
    private EventListener<DamageBlockEvent> damageBlockEvent = new EventListener<>(event -> {
       if (canBreakBlock(event.getBlockPos())) {
           if(last == null || event.getBlockPos() != last) {
               cancel = false;
               if (swingType.getValue() == Swing.Packet) MC.player.networkHandler.sendPacket(new HandSwingC2SPacket(Hand.MAIN_HAND));
               else if (swingType.getValue() == Swing.Real) MC.player.swingHand(Hand.MAIN_HAND);
               MC.player.networkHandler.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getDirection()));
               cancel = true;
           } else {
               if (swingType.getValue() == Swing.Packet) MC.player.networkHandler.sendPacket(new HandSwingC2SPacket(Hand.MAIN_HAND));
               else if (swingType.getValue() == Swing.Real) MC.player.swingHand(Hand.MAIN_HAND);
               MC.player.networkHandler.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getDirection()));
               cancel = true;
           }
           MC.player.networkHandler.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), event.getDirection()));

           render = event.getBlockPos();
           last = event.getBlockPos();
           direction = event.getDirection();

           event.setCancelled(true);
       }
    });

    @EventHandler
    private EventListener<PacketEvent.Sent> onPacketSent = new EventListener<>(event -> {
        Packet packet = event.getPacket();
        if (packet instanceof PlayerActionC2SPacket) {
            PlayerActionC2SPacket digPacket = (PlayerActionC2SPacket) packet;
            if(((PlayerActionC2SPacket) packet).getAction() == PlayerActionC2SPacket.Action.START_DESTROY_BLOCK && cancel) event.setCancelled(true);
        }
    });

    @Override
    public void onTick() {
        if (MathHelper.sqrt(MC.player.squaredDistanceTo(render.getX(), render.getY(), render.getZ())) > repeatRange.getValue())
            render = null;
        else if (MathHelper.sqrt(MC.player.squaredDistanceTo(last.getX(), last.getY(), last.getZ())) <= repeatRange.getValue() && render == null)
            render = last;
        if (render != null && !MC.world.getBlockState(render).getMaterial().isReplaceable()) {
            if (repeatMine.getValue() && repeatTimer.passedMillis(delay.getValue())) {
                if (pickOnly.getValue() && !(MC.player.getStackInHand(Hand.MAIN_HAND).getItem() instanceof PickaxeItem)) {
                    if (autoSwitch.getValue()) {
                        int newSelection = InventoryUtils.findItemInHotbar(Items.NETHERITE_PICKAXE);
                        if (newSelection == -1) newSelection = InventoryUtils.findItemInHotbar(Items.DIAMOND_PICKAXE);
                        if (newSelection != -1) MC.player.inventory.selectedSlot = newSelection;
                        else return;
                    } else return;
                }
                MC.player.networkHandler.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.START_DESTROY_BLOCK, render, direction));
                if (swingType.getValue() == Swing.Packet) MC.player.networkHandler.sendPacket(new HandSwingC2SPacket(Hand.MAIN_HAND));
                else if (swingType.getValue() == Swing.Real) MC.player.swingHand(Hand.MAIN_HAND);
                MC.player.networkHandler.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.STOP_DESTROY_BLOCK, render, direction));
                repeatTimer.reset();
            }
        }
        ReflectionHelper.setPrivateValue(ClientPlayerInteractionManager.class, MC.interactionManager, 0, "blockBreakingCooldown", "field_3716");
    }

    private boolean canBreakBlock(BlockPos blockPos) {
        final BlockState blockState = MC.world.getBlockState(blockPos);
        return blockState.getHardness(MC.world, blockPos) != -1;
    }

    @Override
    public void onRender3d() {
        float red = (float)colorRed.getValue() / 255;
        float green = (float)colorGreen.getValue() / 255;
        float blue = (float)colorBlue.getValue() / 255;
        float fAlpha = (float)fillAlpha.getValue() / 100;
        float bAlpha = (float)boxAlpha.getValue() / 100;
        if(this.render != null) {
            RenderUtils.prepare3d();
            Box bb = RenderUtils.getBoundingBox(this.render);
            if(bb != null) {
                RenderUtils.renderFilledBox(bb, red, green, blue, fAlpha);
                RenderUtils.renderSelectionBoundingBox(bb, red, green, blue, bAlpha);
            }
            RenderUtils.end3d();
        }
    }
}
