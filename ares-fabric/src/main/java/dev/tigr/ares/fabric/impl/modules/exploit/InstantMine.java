package dev.tigr.ares.fabric.impl.modules.exploit;

import dev.tigr.ares.core.feature.module.Category;
import dev.tigr.ares.core.feature.module.Module;
import dev.tigr.ares.core.setting.Setting;
import dev.tigr.ares.core.setting.settings.BooleanSetting;
import dev.tigr.ares.core.setting.settings.EnumSetting;
import dev.tigr.ares.core.setting.settings.numerical.DoubleSetting;
import dev.tigr.ares.core.setting.settings.numerical.FloatSetting;
import dev.tigr.ares.core.setting.settings.numerical.IntegerSetting;
import dev.tigr.ares.core.util.Timer;
import dev.tigr.ares.core.util.render.Color;
import dev.tigr.ares.fabric.event.client.PacketEvent;
import dev.tigr.ares.fabric.event.player.DamageBlockEvent;
import dev.tigr.ares.fabric.mixin.accessors.ClientPlayerInteractionManagerAccessor;
import dev.tigr.ares.fabric.utils.InventoryUtils;
import dev.tigr.ares.fabric.utils.render.RenderUtils;
import dev.tigr.simpleevents.listener.EventHandler;
import dev.tigr.simpleevents.listener.EventListener;
import net.minecraft.block.BlockState;
import net.minecraft.item.Items;
import net.minecraft.item.PickaxeItem;
import net.minecraft.network.Packet;
import net.minecraft.network.packet.c2s.play.HandSwingC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
import net.minecraft.util.Hand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.Direction;

/**
 * @author Makrennel
 * Credit to Kami147 for the module off which this was based.
 */
@Module.Info(name = "InstantMine", description = "Instantly mines blocks after packet mining the first one.", category = Category.EXPLOIT)
public class InstantMine extends Module {
    public static InstantMine INSTANCE;

    private final Setting<Boolean> repeatMine = register(new BooleanSetting("Repeat", true));
    private final Setting<Double> repeatRange = register(new DoubleSetting("Repeat Range", 5, 0, 10)).setVisibility(repeatMine::getValue);
    private final Setting<Integer> delay = register(new IntegerSetting("Delay(ms)", 120, 0, 1200));
    private final Setting<Boolean> pickOnly = register(new BooleanSetting("Only Pickaxe", true));
    private final Setting<Boolean> autoSwitch = register(new BooleanSetting("Auto Switch", false)).setVisibility(pickOnly::getValue);
    private final Setting<Swing> swingType = register(new EnumSetting<>("Swing", Swing.Real));

    private final Setting<Boolean> showRenderOptions = register(new BooleanSetting("Show Render Options", false));
    private final Setting<Float> colorRed = register(new FloatSetting("Red", 0f, 0, 1)).setVisibility(showRenderOptions::getValue);
    private final Setting<Float> colorGreen = register(new FloatSetting("Green", 0f, 0, 1)).setVisibility(showRenderOptions::getValue);
    private final Setting<Float> colorBlue = register(new FloatSetting("Blue", 1f, 0, 1)).setVisibility(showRenderOptions::getValue);
    private final Setting<Float> fillAlpha = register(new FloatSetting("Fill Alpha", 0.63f, 0, 1)).setVisibility(showRenderOptions::getValue);
    private final Setting<Float> boxAlpha = register(new FloatSetting("Line Alpha", 1f, 0, 1)).setVisibility(showRenderOptions::getValue);
    private final Setting<Float> lineThickness = register(new FloatSetting("Line Weight", 2f, 0f, 10f)).setVisibility(showRenderOptions::getValue);
    private final Setting<Float> expandRender = register(new FloatSetting("Box Scale", 0f, -0.12f, 0.06f)).setVisibility(showRenderOptions::getValue);

    enum Swing { None, Real, Packet }

    private Timer repeatTimer = new Timer();
    private BlockPos last = null;
    private BlockPos render = null;
    private boolean cancel = false;
    private Direction direction;

    public InstantMine() {
        INSTANCE = this;
    }

    @EventHandler
    private EventListener<DamageBlockEvent> damageBlockEvent = new EventListener<>(event -> {
       if (canBreakBlock(event.getBlockPos())) {
           if(last == null || event.getBlockPos() != last) {
               cancel = false;
               if(swingType.getValue() == Swing.Packet) MC.player.networkHandler.sendPacket(new HandSwingC2SPacket(Hand.MAIN_HAND));
               else if(swingType.getValue() == Swing.Real) MC.player.swingHand(Hand.MAIN_HAND);
               MC.player.networkHandler.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getDirection()));
               cancel = true;
           } else {
               if(swingType.getValue() == Swing.Packet) MC.player.networkHandler.sendPacket(new HandSwingC2SPacket(Hand.MAIN_HAND));
               else if(swingType.getValue() == Swing.Real) MC.player.swingHand(Hand.MAIN_HAND);
               MC.player.networkHandler.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getDirection()));
               cancel = true;
           }
           MC.player.networkHandler.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), event.getDirection()));

           render = event.getBlockPos();
           last = event.getBlockPos();
           direction = event.getDirection();

           event.setCancelled(true);
       }
    });

    @EventHandler
    private EventListener<PacketEvent.Sent> onPacketSent = new EventListener<>(event -> {
        Packet packet = event.getPacket();
        if (packet instanceof PlayerActionC2SPacket) {
            PlayerActionC2SPacket digPacket = (PlayerActionC2SPacket) packet;
            if(((PlayerActionC2SPacket) packet).getAction() == PlayerActionC2SPacket.Action.START_DESTROY_BLOCK && cancel) event.setCancelled(true);
        }
    });

    @Override
    public void onTick() {
        if(render != null && Math.sqrt(MC.player.squaredDistanceTo(render.getX(), render.getY(), render.getZ())) > repeatRange.getValue())
            render = null;
        else if(last != null && Math.sqrt(MC.player.squaredDistanceTo(last.getX(), last.getY(), last.getZ())) <= repeatRange.getValue() && render == null)
            render = last;
        if(render != null && !MC.world.getBlockState(render).getMaterial().isReplaceable()) {
            if(repeatMine.getValue() && repeatTimer.passedMillis(delay.getValue())) {
                if(pickOnly.getValue() && !(MC.player.getStackInHand(Hand.MAIN_HAND).getItem() instanceof PickaxeItem)) {
                    if(autoSwitch.getValue()) {
                        int newSelection = InventoryUtils.findItemInHotbar(Items.NETHERITE_PICKAXE);
                        if (newSelection == -1) newSelection = InventoryUtils.findItemInHotbar(Items.DIAMOND_PICKAXE);
                        if (newSelection != -1) MC.player.getInventory().selectedSlot = newSelection;
                        else return;
                    } else return;
                }
                MC.player.networkHandler.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.START_DESTROY_BLOCK, render, direction));
                if(swingType.getValue() == Swing.Packet) MC.player.networkHandler.sendPacket(new HandSwingC2SPacket(Hand.MAIN_HAND));
                else if(swingType.getValue() == Swing.Real) MC.player.swingHand(Hand.MAIN_HAND);
                MC.player.networkHandler.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.STOP_DESTROY_BLOCK, render, direction));
                repeatTimer.reset();
            }
        }
        ((ClientPlayerInteractionManagerAccessor) MC.interactionManager).setBlockBreakingCooldown(0);
    }

    private boolean canBreakBlock(BlockPos blockPos) {
        final BlockState blockState = MC.world.getBlockState(blockPos);
        return blockState.getHardness(MC.world, blockPos) != -1;
    }

    // draw target
    @Override
    public void onRender3d() {
        if(render != null) {
            Color fillColor = new Color(colorRed.getValue(), colorGreen.getValue(), colorBlue.getValue(), fillAlpha.getValue());
            Color outlineColor = new Color(colorRed.getValue(), colorGreen.getValue(), colorBlue.getValue(), boxAlpha.getValue());

            RenderUtils.prepare3d();
            RenderUtils.cube(new Box(render), fillColor, outlineColor, lineThickness.getValue());
            RenderUtils.end3d();
        }
    }
}
