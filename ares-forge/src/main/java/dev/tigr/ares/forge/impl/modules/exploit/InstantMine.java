package dev.tigr.ares.forge.impl.modules.exploit;

import dev.tigr.ares.core.feature.module.Category;
import dev.tigr.ares.core.feature.module.Module;
import dev.tigr.ares.core.setting.Setting;
import dev.tigr.ares.core.setting.settings.BooleanSetting;
import dev.tigr.ares.core.setting.settings.EnumSetting;
import dev.tigr.ares.core.setting.settings.numerical.DoubleSetting;
import dev.tigr.ares.core.setting.settings.numerical.IntegerSetting;
import dev.tigr.ares.core.util.global.ReflectionHelper;
import dev.tigr.ares.forge.event.events.player.DamageBlockEvent;
import dev.tigr.ares.forge.event.events.player.PacketEvent;
import dev.tigr.ares.forge.utils.InventoryUtils;
import dev.tigr.ares.forge.utils.RenderUtils;
import dev.tigr.ares.core.util.Timer;
import dev.tigr.simpleevents.listener.EventHandler;
import dev.tigr.simpleevents.listener.EventListener;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.multiplayer.PlayerControllerMP;
import net.minecraft.client.renderer.RenderGlobal;
import net.minecraft.init.Items;
import net.minecraft.item.ItemPickaxe;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketAnimation;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;

/**
 * @author Makrennel
 * Credit to Kami147 for the module off which this was based.
 */
@Module.Info(name = "InstantMine", description = "Instantly mines blocks after packet mining the first one.", category = Category.EXPLOIT)
public class InstantMine extends Module {
    public static InstantMine INSTANCE;

    private final Setting<Boolean> repeatMine = register(new BooleanSetting("Repeat", true));
    private final Setting<Double> repeatRange = register(new DoubleSetting("Repeat Range", 5, 0, 10)).setVisibility(repeatMine::getValue);
    private final Setting<Integer> delay = register(new IntegerSetting("Delay(ms)", 120, 0, 1200));
    private final Setting<Boolean> pickOnly = register(new BooleanSetting("Only Pickaxe", true));
    private final Setting<Boolean> autoSwitch = register(new BooleanSetting("Auto Switch", false)).setVisibility(pickOnly::getValue);
    private final Setting<Swing> swingType = register(new EnumSetting<>("Swing", Swing.Real));

    private final Setting<Boolean> showColorSettings = register(new BooleanSetting("Color Settings", false));
    private final Setting<Integer> colorRed = register(new IntegerSetting("Red", 255, 0, 255)).setVisibility(showColorSettings::getValue);
    private final Setting<Integer> colorGreen = register(new IntegerSetting("Green", 255, 0, 255)).setVisibility(showColorSettings::getValue);
    private final Setting<Integer> colorBlue = register(new IntegerSetting("Blue", 120, 0, 255)).setVisibility(showColorSettings::getValue);
    private final Setting<Integer> fillAlpha = register(new IntegerSetting("Fill Alpha", 24, 0, 100)).setVisibility(showColorSettings::getValue);
    private final Setting<Integer> boxAlpha = register(new IntegerSetting("Box Alpha", 71, 0, 100)).setVisibility(showColorSettings::getValue);

    enum Swing { None, Real, Packet }

    private Timer repeatTimer = new Timer();
    private BlockPos last = null;
    private BlockPos render = null;
    private boolean cancel = false;
    private EnumFacing direction;

    public InstantMine() {
        INSTANCE = this;
    }

    @EventHandler
    private EventListener<DamageBlockEvent> damageBlockEvent = new EventListener<>(event -> {
       if(canBreakBlock(event.getBlockPos())) {
           if(last == null || event.getBlockPos() != last) {
               cancel = false;
               if(swingType.getValue() == Swing.Packet) MC.player.connection.sendPacket(new CPacketAnimation(EnumHand.MAIN_HAND));
               else if(swingType.getValue() == Swing.Real) MC.player.swingArm(EnumHand.MAIN_HAND);
               MC.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
               cancel = true;
           } else {
               if (swingType.getValue() == Swing.Packet) MC.player.connection.sendPacket(new CPacketAnimation(EnumHand.MAIN_HAND));
               else if (swingType.getValue() == Swing.Real) MC.player.swingArm(EnumHand.MAIN_HAND);
               MC.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
               cancel = true;
           }
           MC.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));

           render = event.getBlockPos();
           last = event.getBlockPos();
           direction = event.getEnumFacing();

           event.setCancelled(true);
       }
    });

    @EventHandler
    private EventListener<PacketEvent.Sent> onPacketSent = new EventListener<>(event -> {
        Packet packet = event.getPacket();
        if(packet instanceof CPacketPlayerDigging) {
            CPacketPlayerDigging digPacket = (CPacketPlayerDigging) packet;
            if(((CPacketPlayerDigging) packet).getAction() == CPacketPlayerDigging.Action.START_DESTROY_BLOCK && cancel) event.setCancelled(true);
        }
    });

    @Override
    public void onTick() {
        if(render != null && MC.player.getDistance(render.getX(), render.getY(), render.getZ()) > repeatRange.getValue())
            render = null;
        else if(last != null && MC.player.getDistance(last.getX(), last.getY(), last.getZ()) <= repeatRange.getValue() && render == null)
            render = last;
        if(render != null && !MC.world.getBlockState(render).getMaterial().isReplaceable()) {
            if(repeatMine.getValue() && repeatTimer.passedMillis(delay.getValue())) {
                if(pickOnly.getValue() && !(MC.player.getHeldItem(EnumHand.MAIN_HAND).getItem() instanceof ItemPickaxe)) {
                    if(autoSwitch.getValue()) {
                        int newSelection = InventoryUtils.findItemInHotbar(Items.DIAMOND_PICKAXE);
                        if(newSelection != -1) MC.player.inventory.currentItem = newSelection;
                        else return;
                    } else return;
                }
                MC.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, render, direction));
                if(swingType.getValue() == Swing.Packet) MC.player.connection.sendPacket(new CPacketAnimation(EnumHand.MAIN_HAND));
                else if(swingType.getValue() == Swing.Real) MC.player.swingArm(EnumHand.MAIN_HAND);
                MC.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, render, direction));
                repeatTimer.reset();
            }
        }
        ReflectionHelper.setPrivateValue(PlayerControllerMP.class, MC.playerController, 0, "blockHitDelay", "field_78781_i");
    }

    private boolean canBreakBlock(BlockPos blockPos) {
        final IBlockState blockState = MC.world.getBlockState(blockPos);
        return blockState.getBlockHardness(MC.world, blockPos) != -1;
    }

    @Override
    public void onRender3d() {
        if(this.render != null) {
            float red = (float) colorRed.getValue() / 255;
            float green = (float) colorGreen.getValue() / 255;
            float blue = (float )colorBlue.getValue() / 255;
            float fAlpha = (float) fillAlpha.getValue() / 100;
            float bAlpha = (float) boxAlpha.getValue() / 100;
            RenderUtils.prepare3d();
            AxisAlignedBB bb = RenderUtils.getBoundingBox(this.render);
            RenderGlobal.renderFilledBox(bb, red, green, blue, fAlpha);
            RenderGlobal.drawSelectionBoundingBox(bb, red, green, blue, bAlpha);
            RenderUtils.end3d();
        }
    }
}
